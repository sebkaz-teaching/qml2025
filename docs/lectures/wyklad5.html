<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Algorytmy kwantowego uczenia maszynowego – Wprowadzenie do Kwantowego Uczenia Maszynowego</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-9203b120c5aa9529b4c48b4a2d61fa05.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../style.css">
</head>

<body class="nav-sidebar docked nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Wprowadzenie do Kwantowego Uczenia Maszynowego</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../sylabus.html"> 
<span class="menu-text">Sylabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../ksiazki.html"> 
<span class="menu-text">Książki</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/wyklad1.html">Wykłady</a></li><li class="breadcrumb-item"><a href="../lectures/wyklad5.html">Algorytmy kwantowego uczenia maszynowego</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
      <a href="../index.html" class="sidebar-logo-link">
      </a>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Informacje ogólne</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">Wykłady</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wprowadzenie do obliczeń kwantowych</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Klasyczne bramki logiczne - Algebra Boola</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad5.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Algorytmy kwantowego uczenia maszynowego</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">Ćwiczenia</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/cw1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Modele uczenia maszynowego</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title"><strong>Sections</strong></h2>
   
  <ul class="collapse">
  <li><a href="#pqc-parametrized-quantum-circuits" id="toc-pqc-parametrized-quantum-circuits" class="nav-link active" data-scroll-target="#pqc-parametrized-quantum-circuits">PQC – Parametrized Quantum Circuits</a></li>
  <li><a href="#kodowanie-danych" id="toc-kodowanie-danych" class="nav-link" data-scroll-target="#kodowanie-danych">Kodowanie danych</a></li>
  <li><a href="#kwantowe-algorytmy-wariacyjne" id="toc-kwantowe-algorytmy-wariacyjne" class="nav-link" data-scroll-target="#kwantowe-algorytmy-wariacyjne">Kwantowe Algorytmy Wariacyjne</a></li>
  <li><a href="#quantum-support-vector-classification-qsvm" id="toc-quantum-support-vector-classification-qsvm" class="nav-link" data-scroll-target="#quantum-support-vector-classification-qsvm">Quantum Support Vector Classification (qSVM)</a></li>
  <li><a href="#quantum-neural-networks-qnn" id="toc-quantum-neural-networks-qnn" class="nav-link" data-scroll-target="#quantum-neural-networks-qnn">Quantum Neural Networks (QNN)</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/wyklad1.html">Wykłady</a></li><li class="breadcrumb-item"><a href="../lectures/wyklad5.html">Algorytmy kwantowego uczenia maszynowego</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Algorytmy kwantowego uczenia maszynowego</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Dziedziną łączącą klasyczne uczenie maszynowe i obliczenia kwantowe nazywamy kwantowym uczeniem maszynowym (ang. Quantum Machine Learning).</p>
<p>QML powstało aby szybciej i sprawniej rozwiązywać problemu uczenia maszynowego. Do tego celu chcemy wykorzystać procesory kwantowe oraz własności algorytmów kwantowych i ich przewagę nad klasycznymi odpowiednikami.</p>
<section id="pqc-parametrized-quantum-circuits" class="level2">
<h2 class="anchored" data-anchor-id="pqc-parametrized-quantum-circuits">PQC – Parametrized Quantum Circuits</h2>
<p>Parametryzowane obwody kwantowe (PQC) to podstawowy element współczesnych algorytmów hybrydowych. Ich działanie polega na tym, że stan kwantowy (czyli układ kubitów) jest modyfikowany za pomocą bramek kwantowych zależnych od zestawu parametrów klasycznych — np. kątów rotacji. Zmieniając te parametry, możemy dostosować stan wyjściowy obwodu do konkretnego zadania, np. minimalizacji energii lub klasyfikacji danych.</p>
<p>PQC pełnią podobną rolę jak funkcje z parametrami w klasycznym ML — np. wagi w sieciach neuronowych.</p>
<p>Warto zapamiętać, że nie szukamy tutaj pojedynczego wyniku pomiaru, ale statystycznej właściwości stanu kwantowego zależnej od parametrów.</p>
<section id="rx" class="level3">
<h3 class="anchored" data-anchor-id="rx">RX</h3>
<p>RX to parametryzowana jedno-kubitowa bramka realizująca obroty w osi X na sferze blocha o kąt <span class="math inline">\(\theta\)</span>.</p>
<p>Unitarna realizacja:</p>
<p><span class="math display">\[
RX(\theta) = \exp\left(-i \frac{\theta}{2} X\right) =
\begin{bmatrix}
\cos(\frac{\theta}{2}) &amp; -i \sin(\frac{\theta}{2}) \\
-i \sin(\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2})
\end{bmatrix}
\]</span></p>
<p>Dla <span class="math inline">\(\theta = \pi\)</span>, bramka ta realizuje się jako bramka X.</p>
</section>
<section id="rz" class="level3">
<h3 class="anchored" data-anchor-id="rz">RZ</h3>
<p>RZ to parametryzowana jedno-kubitowa bramka realizująca obroty w osi Z na sferze blocha o kąt <span class="math inline">\(\theta\)</span>.</p>
<p>Unitarna realizacja:</p>
<p><span class="math display">\[
RZ(\theta) = \exp\left(-i \frac{\theta}{2} Z\right) =
\begin{bmatrix}
e^{-i\theta/2} &amp; 0 \\
0 &amp; e^{i\theta/2}
\end{bmatrix}
\]</span></p>
</section>
<section id="ry" class="level3">
<h3 class="anchored" data-anchor-id="ry">RY</h3>
<p>RY to parametryzowana jedno-kubitowa bramka realizująca obroty w osi Y na sferze blocha o kąt <span class="math inline">\(\theta\)</span>.</p>
<p>Unitarna realizacja:</p>
<p><span class="math display">\[
RY(\theta) = \exp\left(-i \frac{\theta}{2} Y\right) =
\begin{bmatrix}
\cos(\frac{\theta}{2}) &amp; - \sin(\frac{\theta}{2}) \\
\sin(\frac{\theta}{2}) &amp; \cos(\frac{\theta}{2})
\end{bmatrix}
\]</span></p>
<p>🌀 Dowolny obrót kubitu</p>
<p>Operator obrotu dla pojedynczego kubitu można zapisać jako:</p>
<p><span class="math display">\[
R(\phi, \theta, \omega) = R_Z(\omega)  R_Y(\theta)  R_Z(\phi)
\]</span></p>
<p>W postaci macierzowej operator ten przyjmuje formę:</p>
<p><span class="math display">\[
R(\phi, \theta, \omega) =
\begin{bmatrix}
e^{-i(\phi+\omega)/2}\cos(\theta/2) &amp; -e^{-i(\phi-\omega)/2}\sin(\theta/2) \\
e^{i(\phi-\omega)/2}\sin(\theta/2) &amp; e^{i(\phi+\omega)/2}\cos(\theta/2)
\end{bmatrix}
\]</span></p>
<p>📋 Szczegóły</p>
<ul>
<li>Liczba kubitów (wires): 1</li>
<li>Liczba parametrów: 3</li>
</ul>
<p>🧮 Przepis na gradient</p>
<p>Pochodna funkcji <span class="math inline">\(f\)</span>, która zależy od operatora <span class="math inline">\(R(\phi, \theta, \omega)\)</span>, względem parametru <span class="math inline">\(\phi\)</span> jest dana wzorem:</p>
<p><span class="math display">\[
\frac{d}{d\phi} f(R(\phi, \theta, \omega)) =
\frac{1}{2}\Big[f(R(\phi + \pi/2, \theta, \omega)) - f(R(\phi - \pi/2, \theta, \omega))\Big]
\]</span></p>
<p>gdzie <span class="math inline">\(f\)</span> jest wartością oczekiwaną (expectation value) zależną od operatora <span class="math inline">\(R(\phi, \theta, \omega)\)</span>.</p>
<p>Ten sam przepis na gradient można zastosować dla każdego z kątów: <span class="math inline">\(\phi, \theta, \omega\)</span>.</p>
<p>💡 Komentarz : Operator <span class="math inline">\(R(\phi, \theta, \omega)\)</span> opisuje dowolny obrót pojedynczego kubitu na sferze Blocha. Sekwencja trzech rotacji wokół osi Z, Y i ponownie Z pozwala uzyskać dowolny stan kwantowy z bazy obliczeniowej — dlatego ten operator jest fundamentem wielu obwodów kwantowych i bramek parametryzowanych (PQC).</p>
</section>
</section>
<section id="kodowanie-danych" class="level2">
<h2 class="anchored" data-anchor-id="kodowanie-danych">Kodowanie danych</h2>
<p>🧠 Klasyczne potoki przetwarzania cech (Classical Feature Pipelines) 1. Czyszczenie danych: obsługa brakujących wartości, normalizacja skali. 2. Kodowanie: konwersja kategorii lub tekstu na wektory liczbowe. 3. Skalowanie i łączenie: skalowanie cech, tworzenie wielomianowych kombinacji lub par interakcyjnych.</p>
<section id="kwantowe-mapy-cech-quantum-feature-maps" class="level3">
<h3 class="anchored" data-anchor-id="kwantowe-mapy-cech-quantum-feature-maps">⚛️ Kwantowe mapy cech (Quantum Feature Maps)</h3>
<ol type="1">
<li>Basis Encoding: mapowanie binarnych cech bezpośrednio na stany bazowe kubitów w bazie obliczeniowej.</li>
<li>Amplitude Encoding: zakodowanie całego wektora danych w amplitudach n kubitów.</li>
<li>Angle Encoding: użycie bramek rotacji <span class="math inline">\(R_X(x_i)\)</span>, <span class="math inline">\(R_Y(x_i)\)</span>, <span class="math inline">\(R_Z(x_i)\)</span> do zakodowania każdej cechy w fazie kubitu.</li>
</ol>
</section>
<section id="kodowanie-w-bazie-obliczeniowej-basis-embedding-encoding" class="level3">
<h3 class="anchored" data-anchor-id="kodowanie-w-bazie-obliczeniowej-basis-embedding-encoding">⚙️ Kodowanie w bazie obliczeniowej (Basis Embedding / Encoding)</h3>
<p>Odpowiednim sposobem kodowania danych binarnych jest tzw. „Basis Embedding” (kodowanie w bazie obliczeniowej).</p>
<p>Klasa BasisEmbedding interpretuje ciąg binarny jako stan bazowy kubitów zgodnie z odwzorowaniem: <span class="math display">\[
b = (b_0, \dots, b_{N-1}) ;\to; \ket{b_0, \dots, b_{N-1}}
\]</span></p>
<p>Załóżmy, że nasze cechy (features) zapisane są jako stan <span class="math display">\[
\ket{111} = \ket{1} \otimes \ket{1} \otimes \ket{1}.
\]</span></p>
<p>Reprezentując stan jako drugi wektor bazowy (standard basis vector), a iloczyn tensorowy jako iloczyn Kroneckera, możemy łatwo potwierdzić wynik prostym obliczeniem:</p>
<p><span class="math display">\[
\ket{1} \otimes \ket{1} \otimes \ket{1} = [0, 0, 0, 0, 0, 0, 0, 1]^T
\]</span></p>
</section>
<section id="kodowanie-w-amplitudach-amplitude-embedding-encoding" class="level3">
<h3 class="anchored" data-anchor-id="kodowanie-w-amplitudach-amplitude-embedding-encoding">⚛️ Kodowanie w amplitudach (Amplitude Embedding / Encoding)</h3>
<p>Jak sama nazwa wskazuje, tablica wartości może zostać użyta jako amplitudy stanu kwantowego, zgodnie z odwzorowaniem: <span class="math display">\[
\alpha = (\alpha_0, \dots, \alpha_{2^N-1}) \to \sum_{k=0}^{2^N-1} \alpha_k \ket{k}
\]</span></p>
<p>W ten sposób każda wartość w wektorze danych klasycznych odpowiada amplitudzie jednego ze stanów bazowych układu kwantowego. Aby stan był fizycznie poprawny, wektor amplitud musi być znormalizowany (tj. suma kwadratów modułów amplitud równa 1).</p>
</section>
<section id="kodowanie-w-kątach-angle-embedding-encoding" class="level3">
<h3 class="anchored" data-anchor-id="kodowanie-w-kątach-angle-embedding-encoding">🔄 Kodowanie w kątach (Angle Embedding / Encoding)</h3>
<p>Najprostszym sposobem kodowania danych rzeczywistych (wartości zmiennoprzecinkowych) jest tzw. „Angle Embedding” (kodowanie w kątach).</p>
<p>Ten rodzaj kodowania przypisuje pojedynczej wartości rzeczywistej x stan kwantowy według odwzorowania: <span class="math display">\[
x \to R_k(x)\ket{0} = e^{-i x \sigma_k /2} \ket{0}
\]</span> gdzie <span class="math inline">\(k \in \{x, y, z\}\)</span> oznacza oś obrotu na sferze Blocha.</p>
<p>Domyślnie w klasie AngleEmbedding oś obrotu ustawiona jest na k = x. Można również wybrać k = y, ale należy unikać k = z, ponieważ obrót wokół osi Z nie zmienia amplitud stanu, a jedynie fazę globalną.</p>
<p>⸻</p>
</section>
<section id="uwaga" class="level3">
<h3 class="anchored" data-anchor-id="uwaga">🔸 Uwaga:</h3>
<p>Rotacje Pauliego są okresowe z okresem <span class="math inline">\(2\pi\)</span> (z dokładnością do fazy globalnej).</p>
<p>Oznacza to, że dane wejściowe warto znormalizować do przedziału <span class="math inline">\([0, \pi)\)</span>, jeśli to możliwe, aby uniknąć wieloznaczności reprezentacji stanu.</p>
</section>
<section id="reprezentacja-kwantowa-danych-quantum-embedding" class="level3">
<h3 class="anchored" data-anchor-id="reprezentacja-kwantowa-danych-quantum-embedding">🔹 Reprezentacja kwantowa danych (Quantum Embedding)</h3>
<p>Reprezentacja kwantowa (quantum embedding) przekształca dane klasyczne w stany kwantowe w przestrzeni Hilberta za pomocą kwantowej mapy cech (feature map).</p>
<p>Proces ten polega na wzięciu klasycznego punktu danych <span class="math inline">\(x\)</span> i przetłumaczeniu go na zestaw parametrów bramek w obwodzie kwantowym, tworząc stan:</p>
<p><span class="math display">\[
\ket{\psi(x)}
\]</span></p>
<p>Ten etap jest kluczowy przy projektowaniu algorytmów kwantowych, ponieważ sposób zakodowania danych bezpośrednio wpływa na moc obliczeniową i zdolność do wykrywania wzorców w danych.</p>
</section>
</section>
<section id="kwantowe-algorytmy-wariacyjne" class="level2">
<h2 class="anchored" data-anchor-id="kwantowe-algorytmy-wariacyjne">Kwantowe Algorytmy Wariacyjne</h2>
<p><img src="../img/VQA.png" alt="model kwantowy" width="80%" height="auto"></p>
<p>Variational Quantum Algorithms należą do klasy algorytmów hybrydowych, w których część obliczeń wykonuje komputer kwantowy, a część klasyczny procesor. Ich celem jest optymalizacja zestawu parametrów, które minimalizują (lub maksymalizują) pewną funkcję kosztu. Proces polega na naprzemiennym uruchamianiu obwodu kwantowego z różnymi wartościami parametrów i wykorzystaniu klasycznego algorytmu (np. gradient descent) do poprawy tych parametrów.</p>
<p>👉 Schemat działania:</p>
<ol type="1">
<li>Zdefiniuj obwód kwantowy zależny od parametrów (PQC).</li>
<li>Zmierz jego wynik i policz wartość funkcji kosztu.</li>
<li>Klasyczny optymalizator aktualizuje parametry.</li>
<li>Powtarzaj, aż osiągniesz minimum.</li>
</ol>
<p>Ten model jest fundamentem takich algorytmów jak VQE czy QAOA.</p>
<p>VQE to jeden z najważniejszych przykładów algorytmu wariacyjnego. Służy do znajdowania najniższej energii (wartości własnej) dla danego operatora Hamiltona — kluczowego w chemii kwantowej i fizyce cząstek.</p>
<p>👉 VQE łączy dwa światy: - Część kwantowa: przygotowuje stan kwantowy za pomocą obwodu parametryzowanego. - Część klasyczna: minimalizuje średnią wartość energii poprzez optymalizację parametrów.</p>
<p>W praktyce pozwala to badać układy molekularne czy materiały bez potrzeby użycia pełnego, kosztownego symulatora kwantowego.</p>
</section>
<section id="quantum-support-vector-classification-qsvm" class="level2">
<h2 class="anchored" data-anchor-id="quantum-support-vector-classification-qsvm">Quantum Support Vector Classification (qSVM)</h2>
<p>Klasyczny algorytm SVM (Support Vector Machine) znajduje hiperpłaszczyznę najlepiej rozdzielającą dane dwóch klas. W wersji kwantowej dane są najpierw kodowane w stanach kwantowych (np. przez amplitude encoding), a następnie mierzona jest odległość lub podobieństwo między nimi w przestrzeni Hilberta.</p>
<p>👉 W kwantowym SVM:</p>
<ul>
<li>dane wejściowe → przekształcane są w stany kwantowe,</li>
<li>jądro (kernel) → jest obliczane poprzez pomiary kwantowe,</li>
<li>klasyfikacja → odbywa się klasycznie, ale korzysta z „kwantowej przestrzeni cech”.</li>
</ul>
<p>Kwantowe jądra mogą umożliwiać separację danych nieliniowo rozdzielnych znacznie efektywniej niż klasyczne jądra.</p>
</section>
<section id="quantum-neural-networks-qnn" class="level2">
<h2 class="anchored" data-anchor-id="quantum-neural-networks-qnn">Quantum Neural Networks (QNN)</h2>
<p>Kwantowe sieci neuronowe to próba przeniesienia idei klasycznych sieci (warstw, wag i funkcji aktywacji) na grunt obwodów kwantowych. Zamiast klasycznych neuronów, wykorzystuje się bramki kwantowe sterowane parametrami, które pełnią funkcję transformacji danych. Proces trenowania QNN przypomina uczenie klasyczne — minimalizujemy funkcję błędu poprzez modyfikację parametrów obwodu.</p>
<p>👉 Główne cechy QNN:</p>
<ul>
<li>Wagi sieci odpowiadają parametrom rotacji w bramkach kwantowych.</li>
<li>Funkcja aktywacji realizowana jest przez pomiar i ponowne przygotowanie stanu.</li>
<li>Dzięki superpozycji, jedna warstwa może reprezentować bardzo złożone zależności danych.</li>
</ul>
<p>W praktyce QNN są obecnie w fazie badań, ale mogą stanowić podstawę przyszłych modeli kwantowych o zdolności uczenia porównywalnej z sieciami klasycznymi.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/sebkaz-teaching\.github\.io\/qml2025");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2025, Sebastian Zając</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>